## 待理解
```
cpuset(7)


```


## 系统编程概念
- 系统调用失败后，利用库函数`perror`和`strerror`根据errno的值打印错误消息
- 左值：指代存储区域的表达式

**特性测试宏**

- 编写可移植性应用程序的时候，有时候会希望头文件只遵循某个特定的标准，而不是最新的；这个时候就需要定义一个或者多个特性测试宏。

- 特性测试宏的作用就是控制unix标准的版本

- 常用的特性测试宏
    - `_POSIX_SOURCE`
    - `_POSIX_C_SOURCE`
    - `_XOPEN_SOURCE`

- 相关文件和资料
    - `<features.h>`
    - `feature_test_macros(7)`

**解释器(interpreter)**
> 所谓解释器就是能够读取并且执行文本格式命令的程序

常见的解释器
- perl，awk，sed
- python，ruby等等

## 文件IO
#### 文件IO基础
**通用IO接口设计**
- open除了可以打开普通文件，还可以打开管道，FIFO，socket，和 terminal
- 对于每个打开的文件，内核都维护着一个文件偏移量
- 使用lseek可以显示的改变文件偏移量
- lseek只能用于普通文件
- ioctl（）不是通用的IO操作

**文件空洞**



**新建文件的访问权限**
新建文件的访问权限由多方面决定：
- open函数的mode
- 进程的umask值
- 父目录的默认访问控制列表

**标准文件描述符**

fd | POSIX name | stdio stream
---|--- | ---
0 | STDIN_FILENO | stdin
1 | STDOUT_FILENO | stdout
2 | STDERR_FILENO | stderr

**文件描述符（fd）与流（stream）**
- 两者都表征着文件的handler，我们可以通过stream/fd来对文件进行读写
- 流是有结构的，具体的可以产看`/usr/include/libio.h`中`struct _IO_FILE{}`
- fd通过如下三个表和文件发生关联
    - 文件描述符表（进程级别）
    - 打开文件表（系统级别）
    - i-node表（系统级别）
- 简单的表述就是：fd指向一个文件句柄（打开文件表中的一项），而文件句柄又指向一个inode项
- stram的抽象级别高于fd，stream是基于fd的

**原子操作**
- 所有系统调用都是以原子操作进行的
-


#### 文件IO缓冲
**内核缓冲kernel buffer cache**
- read和write系统调用在操作磁盘文件时不会直接发起磁盘访问，仅仅是在用户缓冲和内核缓冲之间复制数据
- 

#### 五大文件IO模型
- **阻塞IO**：就是死等<=====>进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。


- **非阻塞IO**：就是轮询；调用进程不停的问内核有木有把数据准备好；如果发现准备好了，就把数据拷贝到用户空间来；在两次询问之间，可以做点其他的事情。


- **IO复用**：多个的进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO；如果select没有监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回，而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据；多个IO，只有一个复用进程会被阻塞。


- **信号驱动IO**：内核把数据准备好，然后通知进程，进程再把数据拷贝到用户空间。具体的，进程想内核注册一个信号处理函数，然后返回，不阻塞；内核数据准备好的时候，给进程发送一个信号，用户进程在信号处理函数中把准备好的数据拷贝到用户空间。


- **异步IO**：应用进程把I/O请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次I/O已经完成。异步IO模型中，进程告诉内核描述符、缓冲区指针、缓冲区大小等相关的信息，内核准备数据然后拷贝，最后通知进程一下下就好。

- 前四种都是同步IO，最后一种是异步IO；
- 所谓同步，就是调用IO的进程会被阻塞；所谓异步，就是调用IO的进程不会被阻塞。

**注意**：IO复用，信号驱动IO的只是监控多个文件描述符，查看哪个文件描述符可以执行IO操作。实际的IO读写，仍然是通过IO系统调用来实现的。

## 日期和时间
**查看HZ的值**
```
cat /boot/config-`uname -r` | grep '^CONFIG_HZ='

```

## 进程
**父进程与子进程**
- 执行fork的时候，子进程会获得父进程所有文件描述符的副本
    - 副本的创建类似于dup
    - 父子进程中对应的描述符指向相同的打开文件句柄
- fork可以理解成对父进程的文本段，数据段，堆栈的复制
- fork和wait组合使用，可以控制进程的内存需求
- fork之后内核先调度父还是子进程，每个准数
- 无论一个子进程何时终止，系统都会向其父进程发送SIGCHLD信号

**fork，vfork与clone**
- fork()通过复制一个与调用进程完全一致的拷贝来创建一个新进程
- vfork()是一种更加高效的fork版本，但是vfork产生的子进程将使用父进程的内存，而且会挂起父进程，应该尽量避免使用
- 对于内核而言，fork(), vfork()以及clone()最后均由同一函数do_fork()实现
- fork <===> clone + flags(SIGCHLD)
- vfork <===> clone + flags(CLONE_VM | CLONE_VFORK | SIGCHLD)
- LinuxThread线程 <===> 4个flags参数
- NPTL线程： 7个flags参数

**exit与_exit**
- exit除了调用_exit，还有如下动作
    - 调用退出处理程序(通过atexit或者on_exit注册)
    - 刷新stdio流缓冲区
    - 使用由status提供的值执行_exit()系统调用

**进程终止的细节**
- 关闭所有打开的对象：文件描述符，目录流，信息目录描述符，转换描述符等等
- 释放所有的文件锁
- 分离已连接的共享内存段
- 关闭该进程打开的所有POSIX有名信号量
- 关闭所有打开的POSIX消息队列


**子进程监控**
- 主进程可以通过wait和waipid监控子进程
- wait一次只能等一个
- 通过宏可以测试子进程退出的状态
    - 正常退出的
    - 被杀死退出的
    - 被停止退出的
    - 等等
- 父进程在处理SIGCHLD信号时，对wait()的调用既可同步，也可异步
- 子进程的终止属于异步事件

**孤儿进程与僵尸进程**
- 父进程已经结束的子进程被成为孤儿进程，由ID为1的进程接管
- 子进程结束后，我们仍然可以调用wait，内核将已经结束了的子进程转化为僵尸进程来处理这种wait的运行
- 僵尸进程已经释放原进程大部分资源，只保留其在进程表中的一条记录
- 僵尸进程无法被信号杀死，SIGKILL也不行



**exec库函数小结**
- 库函数带有l的，参数以列表的形式传进去
- 带有v的，参数以数组的形式传进去
- 带有p的，可以只传文件名
- 带有e的，可以指定环境变量


#### 进程资源
**资源的种类**
- 内存
- CPU时间
- 

**资源限制**
- 资源限制是一个进程级别的限制
- 每个进程都有一组资源限制值
- 资源限制分为软限制(`rlim_cur`) 和 硬限制(`rlim_max`)
- shell 的 内置命令 ulimit 可以设置shell的资源限制
- linux特有的  `/proc/PID/limits`文件可以用来查看相应进程的所有限制值
- 


#### daemon进程
- daemon是长时间运行且没有终端控制的进程
- daemon应该在合适的地方处理SIGTERM和SIGHUB信号
- daemon进程要特别小心内存泄漏和文件描述符泄露
- 使用syslog记录错误消息

## 线程
#### 线程基础
**内核调度实体(KSE)**
- `kernel schedule entity(KSE)` 内核控制实体
- 进程和线程都是KSE
- 区别在于对属性（进程ID，打开的文件描述符，虚拟内存，信号处理函数）的共享程度不同

**线程的特性**
- 所有线程共享相同的全局和堆变量
- 每个线程都有各自的存放局部变量的私有栈
- 同一进程的线程还共享其他属性：当前工作目录，进程ID，打开的文件描述符，信号处置以及资源限制

**进程和线程**
- 进程是资源分配的最小单位，线程是调度的基本单位
- linux下，所谓线程就是轻量级的进程
- 每个线程都在争用宿主进程(host process)中有限的虚拟地址空间：线程栈，线程特有数据，线程局部存储

**线程分离与连接**
- 连接(pthread_join)的目的有两个
    - 等待被连接的线程结束，此时调用线程阻塞
    - 获取被连接线程的返回状态
- 默认情况下，线程是可连接的(joinable)
- 如果不关心线程的返回状态，可以用`pthread_detach`将线程标记为分离状态(detached)，这是，线程结束的时候自动情况并移除
- 一旦线程处于分离态，无法使其重新变成可连接状态

**线程ID**
- POSIX 线程ID 和 gettid()返回的 线程ID 是不同的
- 可以通过`pthread_self()`获取线程ID

#### 线程同步
**互斥量**
- 互斥量(mutex = mutual exclusion)
- 互斥量的作用：保证对任意共享资源的原子访问
- 互斥量的状态：已锁定，未锁定
- 互斥量的分配有动态和静态之分

**条件变量**
- 条件变量就共享变量的状态改变发出通知，互斥量提供对共享变量访问的互斥
- 条件变量总是结合互斥量使用
- 每个条件变量都有与之相关的判断条件(predicate)

#### 线程安全
- 线程安全是针对函数而言的
- 一个函数是线程安全的，指这个函数可以由多个线程同时安全的调用
- 使用全局或者静态变量是导致函数非线程安全的通常原因
- 保障不安全函数的方法
    - 避免使用全局或者静态变量
    - 互斥量
    - 线程特有数据
    - 线程局部存储/变量
- 所谓线程局部存储就是通过`__thread`将static变量变成局部变量
- 只要变量带有`__thread`标志，每个线程都拥有一份该变量的拷贝

## 锁
**各种各样的锁**
- 进程锁
- 线程锁
- 文件锁
    - 死锁
    - 互斥锁mutex
    - 自旋锁spinlock
    - 读写锁rwlock
    - RCU锁：Read Copy Update Lock，读-拷贝-更新 锁
    - 递归锁recursive mutex 可重入锁(reentrant mutex)
    - 非递归锁non-recursive mutex 不可重入锁(non-reentrant mutex)
    - 条件变量condition variables


## 进程间协作
**进程间协作**
- 同步
- 互斥
- 竞争

**两类共享资源**
- 互斥共享资源
    - 信号量是为了解决该问题而引入的机制
- 同步共享资源

**进程间通信工具**
![image](7EFE90A05A7A4891BC1344AE2792BC99)

linux提供的进程间通信工具有三类
- 通信
    - 数据传输
        - 伪终端
        - 字节流：管道，FIFO，流socket
        - 消息：消息队列，数据报socket
    - 共享内存：共享内存，内存映射
- 信号
    - 标准信号
    - 实时信号
- 同步
    - 信号量
    - 文件锁
    - 互斥（线程）
    - 条件变量（线程）

**进程间同步**
linux提供的进程间同步工具有
- 信号量
- 文件锁 

**Linux设备驱动中常见的互斥机制有以下方式：**
- 中断屏蔽
- 原子操作
- 自旋锁
- 信号量

**临界区（critical section）**
- 只能被一个线程执行的代码段
- critical sections: code that can be executed by only one thread at any given time
- 

## Socket编程
#### socket基础
- socket domain:
    - AF_UNIX
    - AF_INET
    - AF_INET6
- socket种类
    - 流socket：类似于双向通信的管道,分为主动和被动,面向连接
    - 数据报socket: 不面向连接
    - 在internet domain: 
        - 流socket使用TCP
        - 数据报socket使用UDP
    
- 关键的几个api：
    - socket()
    - bind()
    - linsen() 
    - accpt()：创建一个新的socket，新的socket与执行connet的对等socket进行连接
    - connect() 
    - close() shutdown()
    - socket IO
        - read() write()
        - send() sendto() recv() recvfrom()

- 数据报socket流程

![image](B89A823653D341789C911228CFE8BDA0)

- 流socket系统

![image](0E3172F880F44D0D828E807E529EBFB8)

#### 网络socket基础

**域名系统**
- 域名系统是一个分布式数据库
- 域名系统的功能是将主机映射到IP地址，或者将IP地址映射到主机



## 终端与伪终端
**终端分类**

终端(tty)是`teletypewriter电传机`的缩写，
- 伪终端（）：/dev/pty/
- 串行端口终端: /dev/ttySn
- 控制终端：/dev/tty
- 虚拟终端：/dev/pts/n
- 

[具体的可以参考知乎文章](https://zhuanlan.zhihu.com/p/90285947)

**面向终端的程序**
- 面向终端的控制程序必须有一个控制终端
- 可以打开/dev/tty获得一个文件描述符
- 产生相关的信号(SIGTSTP, SIGTTIN, SIGINT)

**伪终端()**
- 伪终端是成对的逻辑终端设备
- 伪终端的解决的问题：如何通过网络连接操作另一台主机上的面向终端的程序(比如vi)
- 伪终端提供了网络连接到面向终端程序之间缺失的那一环
- 伪终端有主从之分：主伪终端，从伪终端，又称为伪终端对
- 
